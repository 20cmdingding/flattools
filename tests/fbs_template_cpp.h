// automatically generated by the FlatBuffers compiler, do not modify

#pragma once
#include "flatbuffers/flatbuffers.h"

namespace {{namespace}} {

{% for item in __fbs_meta__['tables'] %}
{% set table_name = item.__name__ %}

struct {{table_name}};
struct {{table_name}}T;

struct {{table_name}}T : public flatbuffers::NativeTable {
{% for member, type in item['_fspec'].items() %}
{% set cpp_type = cpp_types[type[1]] %}
  {{cpp_type}} {{member}};
{% endfor %}
};

struct {{table_name}} FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    {% set i = 4 %}
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endfor %}
  };

  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set MEMBER = member.upper() %}
  {% if (cpp_type != 'std::string') %}
  {{cpp_type}} {{member}}() const { return GetField<{{cpp_type}}>(VT_{{MEMBER}}, 0); }
  bool mutate_{{member}}({{cpp_type}} _{{member}}) { return SetField<{{cpp_type}}>(VT_{{MEMBER}}, _{{member}}); }
  {% else %}
  const flatbuffers::IString *{{member}}() const { return reinterpret_cast<const flatbuffers::IString *>(GetAddressOf(VT_{{MEMBER}})); }
  flatbuffers::IString *mutable_{{member}}() { return reinterpret_cast<flatbuffers::IString *>(GetAddressOf(VT_{{MEMBER}})); }
  {% endif %}
  {% endfor %}

  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
           VerifyField<{{cpp_type}}>(verifier, VT_{{MEMBER}}) &&
     {% endfor %}
           verifier.EndTable();
  }
  void ByteOrderFields() {
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
       {%- if key %}
    flatbuffers::ByteOrderScalar<{{cpp_type}}>(GetAddressOf(VT_{{MEMBER}}));
       {% endif %}
     {% endfor %}
  }
  void FlatbufferOrderFields() {
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
       {%- if key %}
    flatbuffers::FlatbufferOrderScalar<{{cpp_type}}>(GetAddressOf(VT_{{MEMBER}}));
       {% endif %}
     {% endfor %}
  }
  const uint8_t *GetKey() const {
    return GetAddressOf(VT_OBJ_ID);
  }
  size_t GetKeySize() const {
    return GetAddressOf(VT_SCORE) -
      GetAddressOf(VT_OBJ_ID) +
      sizeof(double);
  }
  const uint8_t *GetValue() const {
    return GetAddressOf(VT_COUNTRY);
  }
  size_t GetValueSize() const {
    return GetAddressOf(VT_MYDATA) -
      GetAddressOf(VT_NAME) +
      sizeof(flatbuffers::String) +
      1 * sizeof(flatbuffers::String);
  }
  std::unique_ptr<{{table_name}}T> UnPack() const;
};

struct {{table_name}}Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
       {% if (cpp_type != 'std::string') %}
  void add_{{member}}({{cpp_type}} {{member}}) { fbb_.AddElement<{{cpp_type}}>({{table_name}}::VT_{{MEMBER}}, {{member}}, 0); }
       {% else %}
  void add_{{member}}(flatbuffers::Offset<flatbuffers::String> {{member}}) { fbb_.AddOffset({{table_name}}::VT_{{MEMBER}}, {{member}}); }
       {% endif %}
     {% endfor %}
  {{table_name}}Builder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  {{table_name}}Builder &operator=(const {{table_name}}Builder &);
  flatbuffers::Offset<{{table_name}}> Finish() {
    // FIXME
    auto o = flatbuffers::Offset<{{table_name}}>(fbb_.EndTable(start_, 6));
    fbb_.Required(o, {{table_name}}::VT_COUNTRY);  // country
    return o;
  }
};

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::FlatBufferBuilder &_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% if (cpp_type != 'std::string') %}
    {{cpp_type}} {{member}} = 0,
  {% else %}
    flatbuffers::Offset<flatbuffers::String> {{member}} = 0,
  {% endif %}
  {% endfor %}
  ) {
  {{table_name}}Builder builder_(_fbb);
  {% for member, type in item['_fspec'].items() %}
  builder_.add_{{member}}({{member}});
  {% endfor %}
  return builder_.Finish();
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}Direct(flatbuffers::FlatBufferBuilder &_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% if (cpp_type != 'std::string') %}
    {{cpp_type}} {{member}} = 0,
  {% else %}
    const char *{{member}} = nullptr,
  {% endif %}
  {% endfor %}
  ) {
  return Create{{table_name}}(_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% if (cpp_type != 'std::string') %}
    {{member}},
  {% else %}
    {{member}} ? _fbb.CreateString({{member}}) : 0,
  {% endif %}
  {% endfor %}
  );
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::FlatBufferBuilder &_fbb, const {{table_name}}T *_o);

inline std::unique_ptr<{{table_name}}T> {{table_name}}::UnPack() const {
  auto _o = new {{table_name}}T();
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% if (cpp_type != 'std::string') %}
  { auto _e = {{member}}; _o->{{member}}= _e; };
  {% else %}
  { auto _e = {{member}}((); if (_e) _o->{{member}}= _e->str(); };
  {% endif %}
  {% endfor %}
  return std::unique_ptr<{{table_name}}T>(_o);
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::FlatBufferBuilder &_fbb, const {{table_name}}T *_o) {
  return Create{{table_name}}(_fbb,
  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set key = 'key' in type[2] and (cpp_type != 'std::string') %}
  {% if (cpp_type != 'std::string') %}
    _o->{{member}},
  {% else %}
    {% if key %}
    _fbb.CreateString(_o->{{member}}),
    {% else %}
    _o->{{member}}.size() ? _fbb.CreateString(_o->{{member}}) : 0,
    {% endif %}
  {% endif %}
  {% endfor %}
  );
}

inline const {{table_name}} *Get{{table_name}}(const void *buf) { return flatbuffers::GetRoot<{{table_name}}>(buf); }

inline {{table_name}} *GetMutable{{table_name}}(void *buf) { return flatbuffers::GetMutableRoot<{{table_name}}>(buf); }

inline bool Verify{{table_name}}Buffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<{{table_name}}>(nullptr); }

inline void Finish{{table_name}}Buffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<{{table_name}}> root) { fbb.Finish(root); }

{% endfor %}

}  // namespace {{namespace}}

