// automatically generated by the FlatBuffers compiler, do not modify

#pragma once
#include "flatbuffers/flatbuffers.h"

namespace {{namespace}} {

{% for item in __fbs_meta__['tables'] %}
{% set table_name = item.__name__ %}

struct {{table_name}};
struct {{table_name}}T;

struct {{table_name}}T : public flatbuffers::NativeTable {
{% for member, type in item['_fspec'].items() %}
{% set cpp_type = cpp_types[type[1]] %}
{{cpp_type}} {{member}};
{% endfor %}
};

struct {{table_name}} FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    {% set i = 4 %}
    {% for member, type in item['_fspec'].items() %}
    {% set MEMBER = member.upper() %}
    VT_{{MEMBER}} = {{i}},
    {% set i = i + 2 %}
    {% endfor %}
  };

  {% for member, type in item['_fspec'].items() %}
  {% set cpp_type = cpp_types[type[1]] %}
  {% set MEMBER = member.upper() %}
  {{cpp_type}} {{member}}() const { return GetField<{{cpp_type}}>(VT_{{MEMBER}}, 0); }
  bool mutate_{{member}}({{cpp_type}} _{{member}}) { return SetField<{{cpp_type}}>(VT_{{MEMBER}}, _{{member}}); }
  {% endfor %}

  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
     {% for member, type in item['_fspec'].items() %}
       {% set cpp_type = cpp_types[type[1]] %}
       {% set MEMBER = member.upper() %}
           VerifyField<{{cpp_type}}>(verifier, VT_{{MEMBER}}) &&
     {% endfor %}
           verifier.EndTable();
  }
  void ByteOrderFields() {
    flatbuffers::ByteOrderScalar<int64_t>(GetAddressOf(VT_OBJ_ID));
    flatbuffers::ByteOrderScalar<int64_t>(GetAddressOf(VT_AGE));
    flatbuffers::ByteOrderScalar<int64_t>(GetAddressOf(VT_SCORE));
  }
  void FlatbufferOrderFields() {
    flatbuffers::FlatbufferOrderScalar<int64_t>(GetAddressOf(VT_OBJ_ID));
    flatbuffers::FlatbufferOrderScalar<int64_t>(GetAddressOf(VT_AGE));
    flatbuffers::FlatbufferOrderScalar<int64_t>(GetAddressOf(VT_SCORE));
  }
  const uint8_t *GetKey() const {
    return GetAddressOf(VT_OBJ_ID);
  }
  size_t GetKeySize() const {
    return GetAddressOf(VT_SCORE) -
      GetAddressOf(VT_OBJ_ID) +
      sizeof(double);
  }
  const uint8_t *GetValue() const {
    return GetAddressOf(VT_COUNTRY);
  }
  size_t GetValueSize() const {
    return GetAddressOf(VT_MYDATA) -
      GetAddressOf(VT_NAME) +
      sizeof(flatbuffers::String) +
      1 * sizeof(flatbuffers::String);
  }
  std::unique_ptr<{{table_name}}T> UnPack() const;
};

struct {{table_name}}Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_obj_id(int64_t obj_id) { fbb_.AddElement<int64_t>({{table_name}}::VT_OBJ_ID, obj_id, 0); }
  void add_age(int64_t age) { fbb_.AddElement<int64_t>({{table_name}}::VT_AGE, age, 0); }
  void add_country(flatbuffers::Offset<flatbuffers::String> country) { fbb_.AddOffset({{table_name}}::VT_COUNTRY, country); }
  void add_score(double score) { fbb_.AddElement<double>({{table_name}}::VT_SCORE, score, 0.0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset({{table_name}}::VT_NAME, name); }
  void add_mydata(flatbuffers::Offset<flatbuffers::String> mydata) { fbb_.AddOffset({{table_name}}::VT_MYDATA, mydata); }
  {{table_name}}Builder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  {{table_name}}Builder &operator=(const {{table_name}}Builder &);
  flatbuffers::Offset<{{table_name}}> Finish() {
    auto o = flatbuffers::Offset<{{table_name}}>(fbb_.EndTable(start_, 6));
    fbb_.Required(o, {{table_name}}::VT_COUNTRY);  // country
    return o;
  }
};

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t obj_id = 0,
    int64_t age = 0,
    flatbuffers::Offset<flatbuffers::String> country = 0,
    double score = 0.0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> mydata = 0) {
  {{table_name}}Builder builder_(_fbb);
  builder_.add_mydata(mydata);
  builder_.add_name(name);
  builder_.add_score(score);
  builder_.add_country(country);
  builder_.add_age(age);
  builder_.add_obj_id(obj_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}Direct(flatbuffers::FlatBufferBuilder &_fbb,
    int64_t obj_id = 0,
    int64_t age = 0,
    const char *country = nullptr,
    double score = 0.0,
    const char *name = nullptr,
    const char *mydata = nullptr) {
  return Create{{table_name}}(_fbb, obj_id, age, country ? _fbb.CreateString(country) : 0, score, name ? _fbb.CreateString(name) : 0, mydata ? _fbb.CreateString(mydata) : 0);
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::FlatBufferBuilder &_fbb, const {{table_name}}T *_o);

inline std::unique_ptr<{{table_name}}T> {{table_name}}::UnPack() const {
  auto _o = new {{table_name}}T();
  { auto _e = obj_id(); _o->obj_id = _e; };
  { auto _e = age(); _o->age = _e; };
  { auto _e = country(); if (_e) _o->country = _e->str(); };
  { auto _e = score(); _o->score = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = mydata(); if (_e) _o->mydata = _e->str(); };
  return std::unique_ptr<{{table_name}}T>(_o);
}

inline flatbuffers::Offset<{{table_name}}> Create{{table_name}}(flatbuffers::FlatBufferBuilder &_fbb, const {{table_name}}T *_o) {
  return Create{{table_name}}(_fbb,
    _o->obj_id,
    _o->age,
    _fbb.CreateString(_o->country),
    _o->score,
    _o->name.size() ? _fbb.CreateString(_o->name) : 0,
    _o->mydata.size() ? _fbb.CreateString(_o->mydata) : 0);
}

inline const {{table_name}} *Get{{table_name}}(const void *buf) { return flatbuffers::GetRoot<{{table_name}}>(buf); }

inline {{table_name}} *GetMutable{{table_name}}(void *buf) { return flatbuffers::GetMutableRoot<{{table_name}}>(buf); }

inline bool Verify{{table_name}}Buffer(flatbuffers::Verifier &verifier) { return verifier.VerifyBuffer<{{table_name}}>(nullptr); }

inline void Finish{{table_name}}Buffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<{{table_name}}> root) { fbb.Finish(root); }

{% endfor %}

}  // namespace {{namespace}}

